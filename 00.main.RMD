---
title: "Exercício 1 - Eficiência ADM"
author: "Felipe Gonçalves Pereira"
date: "09/10/2025"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

```{r dea}
# install.packages("Benchmarking")
library(Benchmarking)

# === 1) Dados: DMUs nas linhas, variáveis nas colunas ===
X <- matrix(
  c(8,11,
    14,12,
    11,18,
    16,30,
    24,26,
    36,40),
  ncol = 2, byrow = TRUE
)

Y <- matrix(
  c(42,69,
    24,75,
    120,72,
    80,168,
    120,32,
    88,120),
  ncol = 2, byrow = TRUE
)

rownames(X) <- rownames(Y) <- paste0("DMU", 1:nrow(X))
colnames(X) <- c("Inp1","Inp2")
colnames(Y) <- c("Out1","Out2")

```



```{r dea}

# === 2) DEA CCR (CRS), orientação a insumo, com dual e slacks ===
ET_CRS <- dea(X, Y, RTS = "crs", ORIENTATION = "in", DUAL = TRUE, SLACK = TRUE)

# === 3) Resultados básicos ===
# Eficiências (theta)
theta <- eff(ET_CRS)            # vetor n x 1

# Peers (conjunto de referência) e lambdas
P <- peers(ET_CRS)              # lista de peers por DMU
L <- lambda(ET_CRS)             # matriz n x n (coluna i = lambdas para DMU i)

# Pesos (multiplicadores) do modelo dual
# Obs: no Benchmarking os slots são ux (pesos de saída) e vy (pesos de entrada)
# (mantendo sua convenção)
ux <- ET_CRS$ux
vy <- ET_CRS$vy

# Slacks (sobras) de insumo e produto
sx <- ET_CRS$sx                 # n x m
sy <- ET_CRS$sy                 # n x s

# Pegue os lambdas do objeto e garanta que é matriz
L <- ET_CRS$lambda
if (is.null(dim(L))) {
  L <- matrix(L, nrow = nrow(X), ncol = 1)     # caso raro: veio vetor
}
rownames(L) <- rownames(X)
colnames(L) <- rownames(X)[seq_len(ncol(L))]   # alinha nomes das colunas

# String de peers com pesos (evita "índice fora de limites")
peer_str <- sapply(seq_len(ncol(L)), function(i) {
  idx <- which(L[, i, drop = FALSE] > 1e-8)
  if (length(idx) == 0) return("")
  paste0(rownames(X)[idx], "(", round(L[idx, i, drop = FALSE], 3), ")",
         collapse = ", ")
})

# Tabela final (agora sem erro)
MetasF <- data.frame(
  DMU        = colnames(L),
  eficiencia = round(eff(ET_CRS)[seq_len(ncol(L))], 4),
  peers      = peer_str,
  row.names  = NULL
)

MetasF
L           # matriz de lambdas


```

Como ler seu L atual (exemplos):

- Coluna DMU1: λ(DMU1)=1 → DMU1 é eficiente (ela mesma é referência).
- Coluna DMU2: λ(DMU1)=1.086957 → DMU2 projeta-se na fronteira “sobre a DMU1”.
(Em CRS, a soma dos λ pode passar de 1; em VRS somaria 1.)
- Coluna DMU3: λ(DMU3)=1 e λ(DMU5)=1 → a referência é a combinação de DMU3 e DMU5.
- Coluna DMU6: λ(DMU1)=1.534247 e λ(DMU3)=0.196347 → referência usa DMU1 e DMU3.

Dicas

Quer lambdas que somem 1 (combinação convexa)? Rode o mesmo modelo com RTS = "vrs". Para gráficos da fronteira e projeções, posso te mandar um plot rápido com as DMUs, a fronteira CCR e as setas de projeção.


```{exercicio_1}
# install.packages("Benchmarking")
library(Benchmarking)

## ----------------------
## 1) Dados (6 DMUs do slide)
## ----------------------
X <- matrix(
  c(2,4,   # DMU1
    4,2,   # DMU2
    3,3,   # DMU3
    1,5,   # DMU4
    5,1,   # DMU5
    2,4),  # DMU6 (igual à DMU1 no slide)
  ncol = 2, byrow = TRUE)
Y <- matrix(rep(10, 6), ncol = 1)

rownames(X) <- paste0("DMU", 1:6)
colnames(X) <- c("x1","x2")
rownames(Y) <- paste0("DMU", 1:6)
colnames(Y) <- "y"

## ----------------------
## 2) Lambdas informados (entre aspas)
## ----------------------
L_txt <- "
         DMU1 DMU2     DMU3 DMU4 DMU5 DMU6
DMU1 1.000000    0 0.000000    0    0    0
DMU2 1.086957    0 0.000000    0    0    0
DMU3 0.000000    0 1.000000    0    0    0
DMU4 0.000000    0 0.000000    1    0    0
DMU5 0.000000    0 1.000000    0    0    0
DMU6 1.534247    0 0.196347    0    0    0
"
L <- read.table(text = L_txt, header = TRUE, check.names = FALSE)
L <- as.matrix(L)
rownames(L) <- rownames(X)

## ----------------------
## 3) DEA (CCR, in) e projeções/targets
## ----------------------
dea_crs <- dea(X, Y, RTS = "crs", ORIENTATION = "in", SLACK = TRUE)

theta <- eff(dea_crs)                # eficiência radial
sx    <- dea_crs$sx; sy <- dea_crs$sy
# Targets (ponto projetado na fronteira)
X_target <- sweep(X, 1, theta, "*") - sx
Y_target <- Y + sy

## Pontos de referência pela coluna de lambdas (X_ref = X^T %*% lambda_j)
# (opcional: útil para checar peers)
if (!all(colnames(L) %in% rownames(X))) colnames(L) <- rownames(X)[1:ncol(L)]
X_ref <- t(X) %*% L
colnames(X_ref) <- colnames(L); rownames(X_ref) <- colnames(X)

## ----------------------
## 4) Plot da fronteira eficiente + DMUs + projeções
## ----------------------
op <- par(no.readonly = TRUE)

# 4.1) Janela e DMUs
plot(X[,1], X[,2],
     xlab = "x1 (insumo)", ylab = "x2 (insumo)",
     xlim = c(0, max(X[,1])*1.2), ylim = c(0, max(X[,2])*1.2),
     pch = 19, cex = 1.1)
text(X[,1], X[,2], labels = rownames(X), pos = 3, cex = 0.9)

# 4.2) Fronteira eficiente (isoquanta y=10) – função do pacote
dea.plot.frontier(X, Y, RTS = "crs", ORIENTATION = "in",
                  add = TRUE, lwd = 2)

# 4.3) Destacar DMUs eficientes
is_eff <- abs(theta - 1) < 1e-6
points(X[is_eff,1], X[is_eff,2], pch = 17, cex = 1.4)   # triângulos para eficientes

# 4.4) Setas de projeção (do ponto original até o target na fronteira)
arrows(X[,1], X[,2], X_target[,1], X_target[,2],
       length = 0.08, lwd = 1.5)

legend("topright",
       legend = c("DMUs", "Eficientes (θ=1)", "Fronteira CRS", "Projeções"),
       pch = c(19,17,NA,NA), lty = c(NA,NA,1,1), lwd = c(NA,NA,2,1.5),
       bty = "n")

par(op)

## ----------------------
## 5) (Opcional) Tabela rápida para conferir
## ----------------------
out_tab <- data.frame(
  DMU = rownames(X),
  theta = round(theta, 3),
  x1 = X[,1], x2 = X[,2],
  x1_target = round(X_target[,1], 3),
  x2_target = round(X_target[,2], 3),
  eff = ifelse(is_eff, "eficiente", "ineficiente"),
  row.names = NULL
)
print(out_tab)


```


Exercicio II

Calcular: TMS (utilizando os pesos), input e output



```{exercicio_II}

library(Benchmarking)
X <- matrix(c(100,100,100,100,100,100,100), ncol = 1) 
# preenche a matriz por coluna (by column é o padrão)
Y <- matrix(c(42,70,24,75,120,72,130,180,168,120,32,88,120, 50),ncol = 2)
y1 <- matrix(c(42,70,24,75,120,72,130), ncol = 1)
y2 <- matrix(c(180,168,120,32,88,120,50), ncol = 1)
dea.plot.transform (y1,y2, RTS = "crs", txt=1:dim(rec)[1], GRID=T)
E_IO <- dea(X,Y, RTS="crs", ORIENTATION = "out", DUAL = TRUE, SLACK =TRUE)
eff(E_IO)
E_IO$ux
E_IO$vy
E_IO$vy[,1]/E_IO$vy[,2] 

## Modelo orientado aos outputs
E_OO <- dea(X,Y, RTS="crs", ORIENTATION = "out", DUAL = TRUE, SLACK =TRUE)
eff(E_OO)
E_OO$ux
E_OO$vy

```


Calcular: TMS (utilizando os pesos), input e output

```{exercicio_II_a}
# Pacote
library(Benchmarking)

# ---------- Dados ----------
X <- matrix(c(100,100,100,100,100,100,100), ncol = 1)  # 1 input
Y <- matrix(c(
  42, 70, 24, 75,120, 72,130,   # y1 (7 observações)
 180,168,120, 32, 88,120, 50    # y2 (7 observações)
), ncol = 2, byrow = FALSE)      # preenche por coluna (y1 é a 1ª col)

colnames(X) <- "x1"
colnames(Y) <- c("y1","y2")
n <- nrow(Y)

# ---------- Visual (fronteira em y1 x y2) ----------
# (corrige 'rec' inexistente; usa n como número de DMUs)
dea.plot.transform(y = Y[,1], x = Y[,2], RTS = "crs", txt = 1:n, GRID = TRUE)
# Obs: para um gráfico direto y1 x y2 sem transformar:
plot(Y[,1], Y[,2], pch = 19); text(Y[,1], Y[,2], labels = 1:n, pos = 3)

# ---------- DEA orientado a INSUMO (In) ----------
E_IN <- dea(X, Y, RTS = "crs", ORIENTATION = "in", DUAL = TRUE, SLACK = TRUE)
eff_in  <- eff(E_IN)     # eficiências (θ)
u_in    <- E_IN$ux       # pesos de input (u)
v_in    <- E_IN$vy       # pesos de output (v) do problema dual

# ---------- DEA orientado a PRODUTO (Out) ----------
E_OUT <- dea(X, Y, RTS = "crs", ORIENTATION = "out", DUAL = TRUE, SLACK = TRUE)
eff_out <- eff(E_OUT)    # eficiências (φ)
u_out   <- E_OUT$ux      # pesos de input (u)
v_out   <- E_OUT$vy      # pesos de output (v)

# ---------- TMS entre outputs (usando pesos v) ----------
# Interpretação: TMS_y1,y2 = v_y1 / v_y2 = quanto de y2 "vale" 1 unidade de y1 na fronteira (sombra).
TMS_in   <- v_in[,1]  / v_in[,2]   # TMS obtida no modelo orientado a insumo
TMS_out  <- v_out[,1] / v_out[,2]  # TMS obtida no modelo orientado a produto

# ---------- Tabela resumo ----------
res <- data.frame(
  DMU      = 1:n,
  eff_in   = round(eff_in, 4),
  eff_out  = round(eff_out, 4),
  vy1_in   = round(v_in[,1], 6),
  vy2_in   = round(v_in[,2], 6),
  TMS_in   = round(TMS_in, 6),
  vy1_out  = round(v_out[,1], 6),
  vy2_out  = round(v_out[,2], 6),
  TMS_out  = round(TMS_out, 6)
)
print(res, row.names = FALSE)

# Dica: se quiser a TMS apenas para DMUs eficientes, filtre por eff==1 (no respectivo modelo).
# subset(res, eff_out == 1)  # por exemplo, para a TMS do modelo orientado a produto

```




